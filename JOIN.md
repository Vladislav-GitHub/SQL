SQL-запросы позволяют выбирать и обрабатывать данные не только из одной таблицы — в этом мы уже убедились, когда работали с [[Подзапросы]]. Но таблицы можно также объединять в один результирующий набор записей, связывая их по определённым условиям. Это позволяет делать операция соединения `JOIN`.

Существуют следующие типы соединений таблиц:

1. `INNER JOIN`
2. `LEFT/RIGHT JOIN`  
3. `FULL JOIN`  
4. `CROSS JOIN`  

Операторы соединения включаются в раздел `FROM` запроса. В общем виде, вне зависимости от того, какой тип соединения используется, запрос на объединение таблиц выглядит следующим образом:

`SELECT ...`
`FROM table_1` 
     `JOIN table_2`
     `ON [condition]`
`...`

---

Как правило (но далеко не всегда), в качестве условия [condition], по которому происходит объединение, выступает равенство значений в определённых столбцах. В качестве таких столбцов обычно используются ключи с указанием id (товара, пользователя и т.д.), то есть значений, по которым можно однозначно идентифицировать определённую сущность:

`SELECT table_1.column_1, table_2.column_2`
`FROM table_1` 
     `JOIN table_2`
     `ON table_1.id = table_2.id`
`...`

---

При этом у каждой колонки рекомендуется через точку указывать имя таблицы, которая содержит эту колонку. Более того, это становится уже не рекомендацией, а необходимостью, когда имена столбцов в таблицах совпадают — без явного указания источников база данных не сможет сама определить, какие столбцы и в каких таблицах вы имеете в виду, и в результате вернёт ошибку.

Если имена таблиц слишком длинные, таблицам можно присвоить алиасы. По этим же алиасам можно сразу удобно обращаться к колонкам:

`SELECT a.column_1, b.column_2`
`FROM table_1 a` 
     `JOIN table_2 b`
     `ON a.id = b.id`
`...`

---

Если имя поля, по которому происходит объединение, совпадает в обеих таблицах (как в примерах выше), то можно использовать сокращенную запись c оператором `USING`:

`SELECT a.column_1, b.column_2`
`FROM table_1 a` 
     `JOIN table_2 b`
     `USING (id)`
`...`

---

При объединении таблиц можно также использовать подзапросы. Их можно объединять с другими таблицами или друг с другом:

`SELECT ...`
`FROM table_1`
     `JOIN (`
          `SELECT ...`
          `FROM table_2`
     `) AS subquery`
    `ON table_1.id = subquery.id`
`...`


`SELECT ...`
`FROM (`
     `SELECT ...`
     `FROM table_1`
`) AS subquery_1`
     `JOIN (`
          `SELECT ...`
          `FROM table_2`
     `) AS subquery_2`
    `ON subquery_1.id = subquery_2.id`
`...`

---

Процесс объединения можно представить в виде следующей последовательности операций:

1. Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы. т.е. происходит [декартово произведение](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D1%8F%D0%BC%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5) двух множеств, результатом которого является новое множество, состоящее из всевозможных пар исходных строк. Например, если в одной таблице было 50 записей, а в другой 10, то в результате декартова произведения получится 500 записей. На игрушечном примере это можно представить следующим образом:

![[Pasted image 20241119194932.png]]

2. Затем для каждой объединённой строки, состоящей из строк двух исходных таблиц, проверяется условие соединения, указанное после оператора `ON`.

3. После этого в соответствии с выбранным типом объединения формируется результирующая таблица. 

При соединении не двух, а нескольких таблиц, операция соединения выполняется последовательно несколько раз, т.е. описанный выше алгоритм запускается столько раз, сколько указано соединений. При этом в этой последовательности при каждом объединении может использоваться любой тип соединения (`INNER`, `LEFT` и т.д.).

Для двух соединений запрос может выглядеть примерно следующим образом:

`SELECT a.column_1, b.column_2`
`FROM table_1 a` 
     `LEFT JOIN table_2 b`
     `ON a.user_id = b.user_id`
     `JOIN table_3 c`
     `ON b.order_id = c.order_id`
`...`

---

Первый тип объединения, который мы рассмотрим, называется `INNER JOIN`. Это оператор внутреннего соединения, для которого совершенно неважен порядок указания таблиц, т.е. в следующих случаях результат объединения будет одинаковым:

`SELECT ...`
`FROM table_1 INNER JOIN table_2`
     `ON [condition]`
`...`


`SELECT ...`
`FROM table_2 INNER JOIN table_1` 
     `ON [condition]`
`...`

При этом в запросе вместо `INNER JOIN` можно писать просто `JOIN` — это одно и то же.

Результат объединения `INNER JOIN` формируется следующим образом:
- Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы (происходит декартово произведение).
- Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора `ON`.
- После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.

Таким образом, в результате объединения `INNER JOIN` из двух таблиц отбрасываются все строки, которые не прошли проверку на соответствие указанному условию. Вот и всё!

---

Рассмотрим следующий игрушечный пример:

`SELECT A.id as id,`
       `A.city as city,`
       `B.country as country`
`FROM table_A as A`
     `JOIN table_B as B`
     `ON A.id = B.id`

В результате такого запроса таблицы `table_A` и `table_B` будут объединены в таблицу `table_С`:

![[Pasted image 20241119195449.png]]

Поскольку таблицы совпадают только по одному значению в столбце `id`, то в результат будет включена только одна запись.

Схематично результат работы объединений принято изображать в виде [диаграмм Венна](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0_%D0%92%D0%B5%D0%BD%D0%BD%D0%B0). Для `INNER JOIN` диаграмма выглядит так:

![[Pasted image 20241119195504.png]]


**На заметку:**
Подробнее про `INNER JOIN` можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-inner-join/).

**Пояснение:**
Обратите внимание, что в результате объединения колонки с ключами (в нашем случае это `user_id`) не превращаются в одну общую колонку, а вместе добавляются в результирующую таблицу. То есть сколько было суммарно колонок в двух таблицах, столько окажется и в результирующей таблице после объединения. А уже далее в операторе `SELECT` можно выбирать нужные и проводить над ними операции.

Чтобы обратиться к колонкам с одинаковым именем (`user_id`), пришедшим из разных таблиц, назначьте таблицам алиасы и обратитесь к колонкам через них. Пример, как это можно сделать:

`SELECT A.id as id_a,` 
       `B.id as id_b,` 
       `...`
`FROM table_A as A`
     `JOIN table_B as B`
     `ON A.id = B.id`
`...`

---

Следующий тип соединения, который мы рассмотрим, — это `LEFT OUTER JOIN` (или просто `LEFT JOIN`). 

**`LEFT JOIN` — это оператор внешнего соединения, для которого важен порядок таблиц в запросе, т.е. в отличие от `INNER JOIN` он не является симметричным.**

Поэтому следующие две записи уже не являются эквивалентными:

`SELECT ...`
`FROM table_1 LEFT JOIN table_2`
     `ON [condition]`
`...`


`SELECT ...`
`FROM table_2 LEFT JOIN table_1` 
     `ON [condition]`
`...`

Результат объединения `LEFT JOIN` формируется следующим образом:
- Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
- Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора `ON`.
- После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
- Далее в результат добавляются те записи из левой таблицы (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями `NULL`. 

Если внимательно посмотреть на описанный алгоритм, то можно понять, что он легко сводится к следующей последовательности действий:
1. Сначала в соответствии с указанным условием выполняется `INNER JOIN` первой и второй таблиц.
2. Затем в результат добавляются те записи из левой таблицы (внимание: только из левой), **для которых условие оказалось ложным и которые вошли в соединение на предыдущем шаге**. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями `NULL`.

Вот и вся магия!

Соединение `RIGHT JOIN` работает аналогичным образом, только на втором этапе в результат `INNER JOIN` добавляются записи не из левой, а из правой таблицы.

Давайте снова рассмотрим пару простых примеров.
Так будет выглядеть запрос и его результат с `LEFT JOIN`:

`SELECT A.id as id,`
       `A.city as city,`
       `B.country as country`
`FROM table_A as A`
     `LEFT JOIN table_B as B`
     `ON A.id = B.id`

![[Pasted image 20241119200830.png]]

В данном случае в результат попадёт запись с `id 2`, так как она есть в обеих таблицах, а также запись с `id 1` из левой таблицы.

Диаграмма Венна для `LEFT JOIN` выглядит так:

![[Pasted image 20241119200845.png]]

А вот таким получится результат запроса с `RIGHT JOIN`:

`SELECT B.id as id,`
       `A.city as city,`
       `B.country as country`
`FROM table_A as A`
     `RIGHT JOIN table_B as B`
     `ON A.id = B.id`


![[Pasted image 20241119200908.png]]

Всё как и в случае с `LEFT JOIN`, только в результат уже попадёт недостающая запись с `id 3` из правой таблицы.

Диаграмма Венна для `RIGHT JOIN`:

![[Pasted image 20241119200922.png]]

**На заметку:**
Подробнее про `LEFT JOIN` можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-left-join/).

---

А чтобы лучше разобраться с джойнами, рассмотрим ещё один тип объединения таблиц — `FULL OUTER JOIN` или просто `FULL JOIN`. Это оператор полного внешнего соединения, для которого, **как и для `INNER JOIN`, неважен порядок указания таблиц**. Однако работает он совсем по-другому.

Запрос с `FULL OUTER JOIN` выглядит примерно так:

`SELECT ...`
`FROM table_1 FULL JOIN table_2`
     `ON [condition]`
`...`


`SELECT ...`
`FROM table_2 FULL JOIN table_1` 
     `ON [condition]`
`...`

Результат объединения `FULL JOIN` формируется следующим образом:
- Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
- Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора `ON`.
- После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
- Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из другой таблицы (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями `NULL`.

Этот алгоритм можно свести к следующей последовательности действий:
1. Сначала в соответствии с указанным условием выполняется `INNER JOIN` левой и правой таблиц.
2. Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), **для которых условие оказалось ложным и которые вошли в соединение на предыдущем шаге.** При этом для таких записей соответствующие поля из другой таблицы (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями `NULL`.

Рассмотрим простой пример.
Так будет выглядеть запрос и его результат с `FULL JOIN`:

`SELECT A.id as id,`
       `A.city as city,`
       `B.country as country`
`FROM table_A as A`
     `FULL JOIN table_B as B`
     `ON A.id = B.id`

![[Pasted image 20241119202300.png]]

В результат попала общая запись с `id 2`, а также все недостающие записи из других таблиц. Все несоответствия были заполнены пустыми значениями.

Диаграмма Венна для `FULL JOIN`:

![[Pasted image 20241119202317.png]]

**На заметку:**
Подробнее про `FULL JOIN` можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-full-outer-join/).

---

Запрос с `FULL JOIN` мы вроде бы составили, но как нам теперь определить, что количество записей в полученной таблице совпадает с общим числом уникальных дат в двух таблицах — `users` и `couriers`? Ведь именно столько строк мы и ожидали получить, верно? 

Проверить себя нам помогут операции с множествами. В языке SQL их три:

1. `UNION`
2. `EXCEPT`  
3. `INTERSECT`  

Они позволяют комбинировать результаты нескольких запросов друг с другом и получать один общий результат. Причём именно комбинировать, а не объединять, как это делают джойны.

Эту разницу важно понимать: в операциях с множествами не происходит совмещения столбцов из двух таблиц — база данных просто отбирает строки из таблиц, удовлетворяющие типу операции, и добавляет их в общий результат.

Операции с множествами имеют следующий синтаксис:

1) Операция `UNION` объединяет записи из двух запросов в один общий результат (объединение множеств).

`SELECT column_1, column_2`
`FROM table_1`
`UNION`
`SELECT column_1, column_2`
`FROM table_2`

2) Операция `EXCEPT` возвращает все записи, которые есть в первом запросе, но отсутствуют во втором (разница множеств).

`SELECT column_1, column_2`
`FROM table_1`
`EXCEPT`
`SELECT column_1, column_2`
`FROM table_2`

3) Операция `INTERSECT` возвращает все записи, которые есть и в первом, и во втором запросе (пересечение множеств).

`SELECT column_1, column_2`
`FROM table_1`
`INTERSECT`
`SELECT column_1, column_2`
`FROM table_2`

При этом по умолчанию эти операции исключают из результата строки-дубликаты. Чтобы дубликаты не исключались из результата, необходимо после имени операции указать ключевое слово `ALL`. Например, так:

`SELECT column_1, column_2`
`FROM table_1`
`UNION ALL`
`SELECT column_1, column_2`
`FROM table_2`

Диаграммы Венна для операций выглядят следующим образом:

![[Pasted image 20241119204043.png]]

Для работы этих операций необходимо, чтобы выполнялись следующие условия:
1. В каждом запросе в `SELECT` должно быть одинаковое количество столбцов.
2. Типы данных в столбцах должны быть совместимы.

При этом количество столбцов в операторе `SELECT` может быть любым — главное, чтобы оно было одинаковым.

Например, следующий запрос вернёт уникальные id пользователей, которые что-то заказывали в нашем сервисе, но которых по какой-то причине нет в таблице `users`:

`SELECT user_id`
`FROM user_actions`
`EXCEPT`
`SELECT user_id`
`FROM users`

**На заметку:**
Подробнее про операцию `UNION` можно узнать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-union/). Про `EXCEPT` — [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-except/). Про `INTERSECT` — [тут](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-intersect/).
О теории множеств можно почитать [здесь](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F).

---

`CROSS JOIN` — это просто декартово произведение двух таблиц, то есть именно то, что происходит на первом этапе остальных джойнов. Важное отличие в синтаксисе `CROSS JOIN` состоит в том, что для него не нужно указывать условие для соединения:

`SELECT column_1, column_2, ...`
`FROM table_1`
     `CROSS JOIN table_2`

Тот же результат можно получить с помощью следующей записи:

`SELECT column_1, column_2, ...`
`FROM table_1, table_2`

Рассмотрим простой пример:

`SELECT`
    `A.city as city,`
    `B.country as country`
`FROM table_A as A`
     `CROSS JOIN table_B as B`

С помощью `CROSS JOIN` мы получаем все возможные комбинации значений из первой и второй таблицы:

![[Pasted image 20241119210335.png]]

**На заметку:**
Подробнее с `CROSS JOIN` можно ознакомиться [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cross-join/).

---

Для того чтобы сделать агрегацию значений в колонке в список, необходимо воспользоваться функцией `array_agg`.

`array_agg` — это продвинутая агрегирующая функция, которая собирает все значения в указанном столбце в единый список (`ARRAY`). По сути `array_agg` — это операция, обратная `unnest`, её синтаксис ничем не отличается от синтаксиса остальных агрегирующих функций:

`SELECT column_1, array_agg(column_2) AS new_array`
`FROM table`
`GROUP BY column_1`

**На заметку:**
Подробнее про функцию `array_agg` можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-aggregate-functions/postgresql-array_agg/).

---

И напоследок рассмотрим ещё один тип объединения таблиц, который тоже нужно знать. Это так называемый `SELF JOIN`. 

`SELF JOIN` — не что иное, как объединение таблицы с самой собой. Да, такая операция тоже возможна и, более того, часто бывает полезна.

Присоединить таблицу к самой себе можно с помощью любого рассмотренного ранее типа джойна. Чтобы запрос отработал корректно, таблице нужно присвоить два разных алиаса:

`SELECT ...`
`FROM table_name t1 JOIN table_name t2`
     `ON [condition]`


`SELECT ...`
`FROM table_name t1 LEFT JOIN table_name t2`
     `ON [condition]`


`SELECT ...`
`FROM table_name t1 FULL JOIN table_name t2`
     `ON [condition]`


`SELECT ...`
`FROM table_name t1 CROSS JOIN table_name t2`

**На заметку:**
Подробнее о `SELF JOIN` можно узнать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-self-join/).

---