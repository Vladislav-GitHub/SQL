**Подзапрос — это всего лишь запрос внутри другого запроса.**
Подзапросы могут применяться в следующих частях основного запроса:
- в операторе `FROM`;
- в операторе `SELECT` (если запрос возвращает один столбец с одним значением);
- в операторах `WHERE` и `HAVING` (если запрос возвращает один столбец с одним или несколькими значениями);
- в операторе `CASE` при формировании продвинутых условных конструкций.

---

К результату выполнения подзапроса можно обращаться так же, как и к таблицам в базе данных, т.е. использовать их в блоке `FROM` вместо имеющихся таблиц:

	`SELECT column_1`
	`FROM ( SELECT column_1, column_2 FROM table ) AS subquery_1`

По сути подзапрос — это такая же таблица, только временная. Она формируется в процессе выполнения основного запроса и нигде не сохраняется.

В примере выше сначала будет выполнен подзапрос, который отберёт колонки `column_1` и `column_2` из таблицы `table`, а затем уже из образовавшейся таблицы основной запрос выберет колонку `column_1`.

**Важный момент**: *при использовании подзапроса в блоке `FROM` сформированной в подзапросе таблице необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает!* В примере выше мы обозначили результат подзапроса как `subquery_1`.

Мы уже знаем, что посчитать число пользователей мужского пола можно двумя способами:

	`SELECT sex, COUNT(user_id) AS users_count`
	`FROM users WHERE sex = 'male'`
	`GROUP BY sex`
	
	`SELECT sex, COUNT(user_id) AS users_count`
	`FROM users`
	`GROUP BY sex`
	`HAVING sex = 'male'`

Но то же самое можно сделать и с помощью подзапроса:

	`SELECT sex, users_count`
	`FROM (SELECT sex, COUNT(user_id) AS users_count`
		   `FROM users`
		   `GROUP BY sex) AS subquery`
	`WHERE sex = 'male'`

Что же здесь произошло? Всё довольно просто: в подзапросе мы сначала сгруппировали наши данные по полу и посчитали число пользователей в каждой группе, а потом обратились к результату этого подзапроса, как к таблице, и отобрали с помощью `WHERE` нужную нам группу.

---

Внутри одного запроса может быть сразу несколько подзапросов. Более того, уровней вложенности может быть тоже несколько:

	`SELECT column_1`
	`FROM (SELECT column_1, column_2`
		   `FROM ( SELECT column_1, column_2, column_3`
			    `FROM table ) AS subquery_1) AS subquery_2`

В данном случае последовательность работы запроса такая: сначала будет выполнен подзапрос, возвращающий результат `subquery_1`, затем подзапрос, возвращающий результат `subquery_2`, и только потом в результат основного подзапроса попадёт колонка `column_1`. В результате получается что-то похожее на матрёшку, при этом к основной таблице `table` обращается только самый первый подзапрос `subquery_1`.

К колонкам из подзапроса можно применять агрегирующие функции — так же, как если бы мы обращались к колонкам исходных таблиц:

	`SELECT MAX(column_sum) AS max_sum`
	`FROM (SELECT column_1, SUM(column_2) AS column_sum`
		   `FROM table`
		   `GROUP BY column_1) AS subquery_1`

Здесь сначала в подзапросе мы сгруппируем данные по колонке column_1, посчитав для каждой группы сумму значений в колонке column_2, а затем уже в основном запросе найдём максимальное значение среди всех сумм.

На самом деле вариантов того, как можно использовать подзапросы, очень много. Это крайне полезный функционал, который позволяет формировать продвинутые запросы со сложной логикой. Кроме того, понимание, как работают подзапросы в блоке `FROM`, нам особенно пригодится, когда в следующем уроке мы будем учиться объединять таблицы с помощью оператора `JOIN`.

**Подробнее о том, как работают подзапросы, можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-subquery/).**

---

 А что если один и тот же подзапрос будет использоваться в нескольких частях основного запроса? Неужели каждый раз придётся дублировать один и тот же подзапрос? А что если уровней вложенности будет несколько? Не получится ли тогда слишком сложный и громоздкий запрос, который будет сложно читать?

Для таких случаев в SQL предусмотрен оператор `WITH`, который позволяет создавать так называемые **табличные выражения (CTE, common table expressions)**.

**Табличные выражения — это временные таблицы, существующие только для одного запроса.** Их основное предназначение заключается в разбиении сложных запросов на несколько частей.

Табличные выражения создаются так:

	`WITH subquery_1 AS ( SELECT column_1, column_2`
					    `FROM table )`

После оператора `WITH` указывается название табличного выражения (в данном случае это subquery_1), а затем после ключевого слова `AS` в скобках указывается сам запрос, с помощью которого будет формироваться табличное выражение. Затем в основной части запроса к табличному выражению можно обращаться по имени, как к таблице:

	`WITH subquery_1 AS ( SELECT column_1, column_2`
					    `FROM table )`
	
	`SELECT column_1 FROM subquery_1`

Сравните запрос выше с запросом из прошлого шага:

	`SELECT column_1`
	`FROM (SELECT column_1, column_2`
		   `FROM table) AS subquery_1`

Оператор `WITH` может содержать несколько табличных выражений, причём к указанным ранее выражениям можно обращаться в последующих выражениях:

	`WITH subquery_1 AS ( SELECT column_1, column_2, column_3`
						`FROM table
	),`
	`subquery_2 AS (   SELECT column_1, column_2`
				    `FROM subquery_1 )`
				    
	`SELECT column_1`
	`FROM subquery_2`

Это похоже на код программы: сначала вы создаете некоторые переменные, а затем обращаетесь к ним в последующих её частях. Только в данном случае в качестве переменных выступают таблицы.

Можете снова сравнить запрос выше с запросом из прошлого шага:

	`SELECT column_1`
	`FROM (`
	    `SELECT column_1, column_2`
	    `FROM (`
	        `SELECT column_1, column_2, column_3`
	        `FROM table`
	    `) AS subquery_1`
	`) AS subquery_2`

Результат обоих запросов будет одинаковым.

Использовать в своих запросах оператор `WITH` или нет — решать вам, но в некоторых случаях он может упростить работу с кодом запроса. 

**На заметку:**
**Подробнее про `WITH` и табличные выражения можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cte/).**

---

Ещё одно важное направление применения подзапросов — создание более продвинутых условных выражений в операторах `WHERE` и `HAVING`. Но поскольку и в том, и в другом случае синтаксис и назначение подзапросов примерно одинаковые, в этом уроке мы будем рассматривать всё на примере подзапросов в `WHERE`.

В первую очередь важно понять, что подзапрос, возвращающий одно значение, может использоваться совместно с операторами сравнения.

Иными словами, вы можете составить подзапрос, возвращающий одно значение (как правило, это результат работы агрегирующих функций), а затем сравнить с этим значением (т.е. с подзапросом) все значения в одной из колонок таблицы.

Давайте представим, что нам нужно сравнить значения в каком-то столбце с максимальным, минимальным или средним значением в этом же столбце — такая задача довольно часто встречается на практике. Сделать это в рамках одного запроса точно не получится, поскольку, как мы уже знаем, агрегирующие функции нельзя применять в блоке `WHERE`.

Первое, что приходит в голову — написать примерно такой запрос:

	`SELECT column`
	`FROM table`
	`WHERE column = MAX(column)`

Но по понятным причинам работать он не будет, и база данных сообщит об ошибке.

Однако хотя запрос и некорректный, его логика в целом правильная: нам действительно нужно найти максимальное значение в колонке и сравнить с ним все значения в этой же колонке. Единственное, что мы забыли, когда считали максимальное значение, это обратиться к самой таблице.

Давайте это исправим и перепишем запрос следующим образом:

	`SELECT column`
	`FROM table`
	`WHERE column = ( SELECT MAX(column)`
				    `FROM table )`

В результате выполнения такого запроса мы получим все значения в колонке `column`, равные максимальному значению в этой колонке.

Такой запрос отработает уже без ошибок, так как подзапрос с расчётом максимального значения выполнится первым и вернёт одно значение.

---

Результат подзапроса, возвращающего столбец с одним значением, также можно использовать в арифметических операциях:
	
	`SELECT column`
	`FROM table`
	`WHERE column = ( SELECT MAX(column)`
					`FROM table ) - 100`

Более того, с помощью подзапросов вы можете брать необходимые вам значения из нескольких разных таблиц и использовать их в качестве переменных внутри основного запроса:

	`SELECT column`
	`FROM table`
	`WHERE column >= (SELECT MAX(column_1)`
					`FROM table_1) - 100`
	`AND column <= (SELECT MAX(column_2)`
				   `FROM table_2)`

То есть в данном случае **результат выполнения подзапроса можно рассматривать как некоторую переменную**. Со временем число записей в таблицах может меняться (допустим, появляются новые товары по новым ценам или новые заказы с более поздними датами), и наши подзапросы будут это учитывать, каждый раз заново рассчитывая необходимые нам значения — согласитесь, довольно удобный функционал.

**На заметку:**
Если же в одном запросе используется несколько разных «переменных» из подзапросов или к одному и тому же подзапросу нужно обращаться несколько раз, тогда имеет смысл вынести эти подзапросы в начало основного запроса в виде табличных выражений в блоке `WITH`.

	`WITH` 
	`subquery AS (`
	    `SELECT MAX(column_2)`
	    `FROM table_2`
	`)`
	
	`SELECT column_1`
	`FROM table_1`
	`WHERE column_1 = (SELECT * FROM subquery)` 

Обратите внимание на запись со «звёздочкой». Дело в том, что обратиться к этим «переменным» просто по имени табличного выражения не получится — придётся отдельным подзапросом из табличного выражения выбрать рассчитанное значение. Самый простой вариант — написать подзапрос с `SELECT *` из табличного выражения.

Если «переменных» несколько, то запрос может выглядеть так:

	`WITH`
	`subquery_1 AS (`
	    `SELECT MAX(column_1)`
	    `FROM table_1`
	`),`
	`subquery_2 AS (`
	    `SELECT MAX(column_2)`
	    `FROM table_2`
	`)`
	
	`SELECT column`
	`FROM table`
	`WHERE column >= (SELECT * FROM subquery_1) - 100`
	`AND column <= (SELECT * FROM subquery_2)`

Такая запись может показаться громоздкой, но в некоторых случаях, когда одни и те же подзапросы необходимо использовать несколько раз по ходу основного запроса, она может существенно упростить ваш код.

---

В каких ещё случаях на практике нам может пригодиться подзапрос в операторе `WHERE`?

Давайте представим, что нам нужно провести какие-нибудь расчёты за последние N дней — скажем, за последнюю неделю. Не будем же мы вручную отсчитывать 7 дней от последней даты в нашей таблице? Разумеется, не будем, так как последняя дата может со временем измениться, когда к нам поступят новые данные. Каждый раз писать новый запрос и считать дату вручную — занятие не для нас.

Для решения такой задачи мы можем сначала с помощью подзапроса вычислить последнюю дату в наших данных, а затем отложить от неё неделю.

Чтобы отложить от даты или прибавить к ней какой-то промежуток времени, можно использовать несложные арифметические операции с датами. Например, от текущей даты можно отнять заданный промежуток `INTERVAL`:

	`SELECT NOW() - INTERVAL '1 year 2 months 1 week'`
	`Результат: 10/10/21 19:32`

---

Кстати, `NOW` — полезная функция, которая позволяет получать текущую дату и время (в вашем случае она будет другой, как и результат запроса выше):

	`SELECT NOW()`
	`Результат: 17/12/22 19:32`

---

**На заметку:**
С другими примерами работы с `INTERVAL` и арифметическими операциями с датами можно ознакомиться [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-interval/).
Про функцию `NOW` можно дополнительно почитать [тут](https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-now/).

---

**Важное уточнение**: подзапросы могут выступать в качестве аргументов функций, т.е. к результату выполнения подзапросов можно применять функции, принимающие на вход какие-то значения. Так, например, подзапросы можно указывать в качестве аргументов функций `CONCAT` или `COALESCE`:

	`SELECT CONCAT(`
	              `'Начало периода: ', (SELECT MIN(date) FROM table),` 
	              `' ',` 
	              `'Конец периода: ', (SELECT MAX(date) FROM table)`
	       `)`
	
	`SELECT COALESCE((SELECT MAX(date) FROM table), NOW())`

В таком случае результат выполнения подзапроса будет подставляться в функцию для дальнейших расчётов.

Чтобы весь запрос выглядел компактнее, для приведения данных к другому типу можно использовать формат записи с двумя двоеточиями — `::`

---

Всё это время мы говорили о подзапросах, возвращающих одно значение в результате применения агрегирующих функций. Теперь рассмотрим случаи, когда подзапрос возвращает несколько значений, и узнаем, как это можно использовать для продвинутой фильтрации данных в таблицах.

Подзапрос, возвращающий несколько значений, может использоваться в блоке `WHERE` совместно с оператором `IN` — например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, полученного в результате выполнения подзапроса.

Выглядит это так:
	
	`SELECT column_1`
	`FROM table_1`
	`WHERE column_1 IN (SELECT column_2 FROM table_2)`

Сначала подзапрос отберёт все значения в колонке column_2 из таблицы table_2, а затем выберет те записи из таблицы table_1, где в колонке column_1 значение совпадает с одним из значений в колонке column_2, полученной в результате подзапроса. Обратите внимание, что использовать `DISTINCT` в подзапросе необязательно, т.к. на результат основного запроса это никак не повлияет — по большому счёту нет разницы, будут значения в списке уникальными или нет.

При этом запрос выше будет равносилен запросу с табличным выражением:

	`WITH` 
	`subquery AS (`
	    `SELECT column_2`
	    `FROM table_2`
	`)`
	
	`SELECT column_1`
	`FROM table_1`
	`WHERE column_1 IN (SELECT * FROM subquery)` 

Снова обратите внимание, что при использовании в операторе `WHERE` табличного выражения обратиться просто к его имени нельзя — необходимо предварительно выбрать все его записи, т.е. написать подзапрос. При этом в табличном выражении должен быть всего один столбец, иначе база данных вернёт ошибку.

---

Вложенный запрос может располагаться и после оператора `SELECT`. Однако тогда результатом подзапроса может быть только одно значение — например, результат применения агрегирующей функции к некоторой колонке:

	`SELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1`
	`FROM table`

В этом примере из таблицы table будет выбрана колонка column_1, и напротив каждого значения в этой колонке будет выведен результат выполнения вложенного запроса, т.е. максимальное значение в колонке. При этом давать алиас результату подзапроса не обязательно.

По сути эта операция равносильно тому, как если бы мы просто проставили одно и то же значение в отдельном столбце, посчитав его вручную:

	`SELECT column_1, 1500 AS max_column_1`
	`FROM table`

Разница заключается в том, что с помощью подзапроса мы делаем это значение динамическим и избавляем себя от необходимости постоянно его обновлять.

Также результаты подзапросов в блоке `SELECT` можно сразу использовать в вычислениях:

	`SELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2`
	`FROM table`

На практике подзапрос в `SELECT` может использоваться для того, чтобы сравнить значения в колонке с каким-нибудь одним расчётным значением (из той же или другой таблицы):

	`SELECT column_1, column_2, column_2 > (SELECT MAX(column_1) FROM table) AS column_3`
	`FROM table`

**На заметку:**
На самом деле для того, чтобы в отдельном столбце вывести расчёты с агрегацией по колонкам в той же таблице, не меняя при этом её структуру, чаще используются не подзапросы, а [[Оконные функции]] — продвинутый функционал.

---

Подзапросы также могут использоваться в операторе `CASE` при формировании сложных условных конструкций. Это бывает полезно, когда необходимо сравнить значения в некотором столбце с одним значением, рассчитанным по той же или другой таблице. Или, например, в случаях, когда для каждой записи в таблице нужно проверить вхождение значения в колонке в определённое множество значений из другой таблицы.

Допустим, у нас есть две таблицы, в которых хранятся почты старых и новых клиентов, и нам необходимо «подтянуть» эту информацию в таблицу c заказами. Сделать это можно так:

	`SELECT client_id, email, order_id,`
	    `CASE` 
	    `WHEN email IN (SELECT email FROM clients_new)`
	    `THEN 'new'`
	    `WHEN email IN (SELECT email FROM clients_old)`
	    `THEN 'old'`
	    `ELSE 'unknown'`
	    `END AS client_type`
	`FROM orders`

---

**На заметку:**
Подзапросы можно также использовать и в операторе `FILTER` для формирования ещё более продвинутых условий фильтрации. В таком случае конструкция будет иметь следующий вид:

	`SELECT COUNT(column) FILTER (WHERE column > (SELECT AVG(column) FROM table)) AS count`
	`FROM table`

Такой запрос посчитает количество значений в колонке column, которые превышают среднее значение по этой же колонке. Разумеется, в подзапросе, указанном в `FILTER`, можно обращаться и к другим колонкам и таблицам, применяя любые другие способы фильтрации — например, оператор `IN`:

	`SELECT COUNT(column_1) FILTER (WHERE column_1 IN (SELECT column_2 FROM table_2)) AS count`
	`FROM table_1`

---

Чтобы перевести значение интервала в минуты, необходимо извлечь из него количество секунд, а затем поделить это значение на количество секунд в одной минуте. Для извлечения количества секунд из интервала можно воспользоваться следующей конструкцией:

	`SELECT EXTRACT(epoch FROM INTERVAL '3 days, 1:21:32')
	Результат: 264092`

Функция `EXTRACT` работает аналогично функции `DATE_PART`.

**На заметку:**
Подробнее про функцию `EXTRACT` можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-extract/).

---

Функция `unnest` предназначена для разворачивания массивов и превращения их в набор строк:

	`SELECT unnest(ARRAY['one','two','three'])`
	`Результат: one two three`

Развернуть массив означает превратить его в набор записей, где каждой строчке будет соответствовать значение, входящее в массив.

В примере выше функция `unnest` превратила исходный список из трёх элементов в набор из трёх строк.

Если бы в исходной таблице помимо списка был столбец с каким-либо значением, то это значение автоматически проставилось бы напротив значений в каждой образовавшейся строке:

	`SELECT 'row', unnest(ARRAY['one','two','three'])`
	`Результат:`
	`row    one`
	`row    two`
	`row    three`

В нашем случае мы имеем таблицу с id заказов и списками id товаров, входящих в заказ. Допустим, таблица выглядит так:

| order_id | product_ids |
| -------- | ----------- |
| 1001     | [5, 8, 15]  |
| 1002     | [2]         |
| 1003     | [4, 11, 21] |

Если развернуть массивы в колонке product_ids, то записей с id каждого заказа станет ровно столько, сколько было товаров в массиве, соответствующем эту заказу. Внимательно посмотрите на результат запроса применения функции `unnest` к колонке product_ids:

	`SELECT order_id, unnest(product_ids) AS product_id`
	`FROM orders`

| order_id | product_ids |
| -------- | ----------- |
| 1001     | 5           |
| 1001     | 8           |
| 1001     | 15          |
| 1002     | 2           |
| 1003     | 4           |
| 1003     | 11          |
| 1003     | 21          |

**На заметку:**
Дополнительные примеры использования функции `unnest` можно найти [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-array/).
