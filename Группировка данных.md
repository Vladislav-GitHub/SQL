
**Как выполняется группировка с оператором GROUP BY:**
1. Сначала в таблице определяются строки, в которых в указанном в `GROUP BY` столбце есть одинаковые значения.
2. Далее по этим значениям записи объединяются в группы, причём в группе может быть даже одна запись.  
3. После этого с помощью агрегирующих функций над элементами этих групп, как правило, проводятся определённые операции. Например, с помощью `SUM` вычисляется сумма значений в каком-либо столбце в каждой группе:

	`SELECT column_1, SUM(column_2) AS sum`
	`FROM table`
	`GROUP BY column_1`

4. Затем в результирующий запрос попадает по одной уникальной записи из столбца, по которому осуществлялась группировка. При этом напротив каждого такого значения отражается результат агрегации по соответствующей группе, если агрегация проводилась.

---

А теперь сделаем несколько важных уточнений.
— Во-первых, группировку можно делать сразу по нескольким колонкам:

`SELECT column_1, column_2, SUM(column_3) AS sum`
`FROM table`
`GROUP BY column_1, column_2`

В таком случае количество групп в результирующей таблице будет равно числу уникальных комбинаций значений в нескольких столбцах, указанных в `GROUP BY`. При этом для каждой такой группы будет проведена агрегация значений по колонке, указанной в качества аргумента агрегирующей функции.

---

— Во-вторых, к группам, образовавшимся в результате `GROUP BY`, можно применять сразу несколько агрегирующих функций (в том числе к разным колонкам):

`SELECT column_1, SUM(column_2) AS sum, AVG(column_3) AS avg FROM table`
`GROUP BY column_1`

---

При этом агрегирующую функцию можно применить к той же самой колонке, по которой осуществляется группировка:

`SELECT column_1, COUNT(column_1) AS count`
`FROM table`
`GROUP BY column_1`

Не всегда такая операция имеет смысл, но она допустима. Например, с помощью функции `COUNT` можно посчитать количество записей, попавших в каждую группу.

---

— В-третьих, после группировки к результатам агрегирующих функций можно применять другие функции. Также над ними можно сразу проводить арифметические операции:

`SELECT column_1, ROUND(SUM(column_2), 2) AS rounded_sum`
`FROM table`
`GROUP BY column_1`

`SELECT column_1, SUM(column_2)::DECIMAL / SUM(column_3) * 100 AS share`
`FROM table GROUP BY column_1`

---

— В-четвёртых, агрегацию не обязательно проводить по уже имеющимся колонкам — можно сначала применить некоторую функцию в колонке из исходной таблицы, а затем сразу провести агрегацию по новой колонке:

`SELECT column_1, SUM(some_function(column_2)) AS sum_over_function`
`FROM table`
`GROUP BY column_1`

---

— В-пятых, группировку можно делать сразу по новым полям, посчитанным в `SELECT`. **При этом допускается использование в `GROUP BY` алиаса колонки, указанного в `SELECT` из-за того, что GROUP BY применяется после SELECT.**

(Однако такой «синтаксический сахар» есть не в каждой СУБД, поэтому при работе с другими инструментами будьте аккуратны — в общем случае рекомендуется дублировать расчётное поле в блоке `GROUP BY` и не использовать в нём алиасы колонок из `SELECT`)

Например, если нам необходимо сгруппировать данные по дням, выделив дату из какой-то колонки, и посчитать сумму некоторых значений в каждый из дней, то можно использовать следующие запросы, которые дадут одинаковый результат:

`SELECT DATE(column_1) AS date, SUM(column_2) AS sum`
`FROM table`
`GROUP BY DATE(column_1)`

`SELECT DATE(column_1) AS date, SUM(column_2) AS sum`
`FROM table`
`GROUP BY date`

---

— В-шестых, делать агрегацию после группировки не обязательно. Если не указать агрегирующую функцию, то запрос вернёт уникальные значения в столбце (или уникальные комбинации значений в столбцах), т.е. тот же результат, что и оператор `DISTINCT`:

`SELECT user_id`
`FROM user_actions`
`GROUP BY user_id`

`SELECT DISTINCT user_id`
`FROM user_actions`

*Вопрос о том, какими способами можно отобрать уникальные значения в столбце, часто встречается на собеседованиях.*

---

— В-седьмых, **при использовании группировки колонки, указанные в `SELECT`, должны находиться и в `GROUP BY`, если они не используются в агрегирующих функциях**.

Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.

Следующий запрос работать не будет, так как в `GROUP BY` указаны не все неагрегированные колонки из блока `SELECT`: 

`SELECT column_1, column_2, SUM(column_3) AS sum`
`FROM table`
`GROUP BY column_1`

То есть в запросе выше мы сгруппировали данные по колонке column_1, но при этом попросили базу данных вывести группировку по колонкам column_1 и column_2 с расчётом суммы некоторых значений в колонке column_3. Так делать нельзя.

В данном случае правильным был бы следующий запрос:

`SELECT column_1, column_2, SUM(column_3) AS sum`
`FROM table`
`GROUP BY column_1, column_2`

---

Обратите внимание, что в обратную сторону указанное выше правило не работает: если мы что-то указали в `GROUP BY`, то это совсем не обязательно указывать в `SELECT`. Иными словами, можно не выводить наименования колонок, по которым осуществляется группировка.

Например, в этом запросе в блоке `SELECT` нет колонки, указанной в `GROUP BY`. Тем не менее такой запрос всё равно сработает:

`SELECT SUM(column_2) AS sum`
`FROM table`
`GROUP BY column_1`

Дело в том, что сама группировка всегда происходит до выполнения блока `SELECT`, где мы по сути указываем, что включить в результат. То есть даже если мы не укажем колонку в `SELECT`, но укажем её в `GROUP BY`, группы всё равно будут сформированы, но их наименования просто не будут включены в результирующую таблицу.

---

— И наконец, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в `WHERE` и только потом данные группируются с помощью `GROUP BY`:

`SELECT column_1, SUM(column_2) AS sum`
`FROM table`
`WHERE column_3 > 0`
`GROUP BY column_1`

---

И ещё: вместо названий колонок в блоке `GROUP BY` можно использовать порядковые номера колонок, указанных в `SELECT`. Например, следующие запросы эквивалентны:

`SELECT column_1, column_2, SUM(column_3) AS sum`
`FROM table`
`GROUP BY column_1, column_2`

`SELECT column_1, column_2, SUM(column_3) AS sum`
`FROM table`
`GROUP BY 1, 2`

При этом номера колонок из `SELECT` можно также использовать при сортировке в операторе `ORDER BY`:

`SELECT column_1, column_2, SUM(column_3) AS sum`
`FROM table`
`GROUP BY 1, 2`
`ORDER BY 3`

---

Функция `DATE_TRUNC` используется для усечения дат и времени, т.е. она работает аналогично округлению `ROUND`, только для типов данных `TIMESTAMP` и `INTERVAL`.

Синтаксис у неё такой же, как и у `DATE_PART`:

`SELECT DATE_TRUNC(part, column)`

На месте part в кавычках указывается, до какой точности следует округлять переданное значение времени:  `'year'`, `'month'`, `'day'`, `'hour'` и т.д.

Возвращаемое значение имеет тип `TIMESTAMP` или `INTERVAL`, а все «части» исходного значения, менее значимые, чем заданная «часть», приравниваются к нулю (или единице, если это номер дня или месяца):

`SELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30') Результат: 01/01/22 00:00`

`SELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30') Результат: 12/01/22 00:00`

`SELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30') Результат: 12/01/22 08:00`